================================================================================
PHARMA CLASSIFICATION NOTEBOOK - FULL EXPORT
================================================================================


================================================================================
CELL 1 (CODE)
================================================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


================================================================================
CELL 2 (CODE)
================================================================================
df = pd.read_csv("project-data.csv",sep=";", skipinitialspace=True)

================================================================================
CELL 3 (CODE)
================================================================================
df.head()

--- OUTPUT ---
     category  age sex  albumin  alkaline_phosphatase  \
0  no_disease   32   m     38.5                  52.5   
1  no_disease   32   m     38.5                  70.3   
2  no_disease   32   m     46.9                  74.7   
3  no_disease   32   m     43.2                  52.0   
4  no_disease   32   m     39.2                  74.1   

   alanine_aminotransferase  aspartate_aminotransferase  bilirubin  \
0                       7.7                        22.1        7.5   
1                      18.0                        24.7        3.9   
2                      36.2                        52.6        6.1   
3                      30.6                        22.6       18.9   
4                      32.6                        24.8        9.6   

   cholinesterase  cholesterol  creatinina  gamma_glutamyl_transferase   \
0            6.93         3.23       106.0                         12.1   
1           11.17         4.80        74.0                         15.6   
2            8.84         5.20        86.0                         33.2   
3            7.33         4.74        80.0                         33.8   
4            9.15         4.32        76.0                         29.9   

  protein     
0         69  
1       76.5  
2       79.3  
3       75.7  
4       68.7  

================================================================================
CELL 4 (CODE)
================================================================================
df.columns.tolist()
df.columns = df.columns.str.strip()
print(df.columns.tolist())



--- OUTPUT ---
['category', 'age', 'sex', 'albumin', 'alkaline_phosphatase', 'alanine_aminotransferase', 'aspartate_aminotransferase', 'bilirubin', 'cholinesterase', 'cholesterol', 'creatinina', 'gamma_glutamyl_transferase', 'protein']


================================================================================
CELL 5 (CODE)
================================================================================
df.isnull().sum()

--- OUTPUT ---
category                      0
age                           0
sex                           0
albumin                       0
alkaline_phosphatase          0
alanine_aminotransferase      1
aspartate_aminotransferase    0
bilirubin                     0
cholinesterase                0
cholesterol                   0
creatinina                    0
gamma_glutamyl_transferase    0
protein                       0
dtype: int64

================================================================================
CELL 6 (CODE)
================================================================================
for col in ["albumin","alkaline_phosphatase","cholesterol","alanine_aminotransferase"]:
    df[col].fillna(df[col].median(),inplace=True)
df.isnull().sum()

--- OUTPUT ---
C:\Users\sreed\AppData\Local\Temp\ipykernel_12144\3019689553.py:2: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  df[col].fillna(df[col].median(),inplace=True)
category                      0
age                           0
sex                           0
albumin                       0
alkaline_phosphatase          0
alanine_aminotransferase      0
aspartate_aminotransferase    0
bilirubin                     0
cholinesterase                0
cholesterol                   0
creatinina                    0
gamma_glutamyl_transferase    0
protein                       0
dtype: int64

================================================================================
CELL 7 (CODE)
================================================================================
df.nunique()


--- OUTPUT ---
category                        5
age                            49
sex                             2
albumin                       190
alkaline_phosphatase          414
alanine_aminotransferase      341
aspartate_aminotransferase    297
bilirubin                     188
cholinesterase                407
cholesterol                   313
creatinina                    117
gamma_glutamyl_transferase    358
protein                       199
dtype: int64

================================================================================
CELL 8 (MARKDOWN)
================================================================================
***EDA Code**
**1Ô∏è‚É£ Target Variable Distribution**

================================================================================
CELL 9 (CODE)
================================================================================
plt.figure(figsize=(6,4))
sns.countplot(x=df['category'])
plt.title("Distribution of Liver Disease Categories")
plt.xticks(rotation=15)
plt.show()


--- OUTPUT ---


================================================================================
CELL 10 (MARKDOWN)
================================================================================
**2Ô∏è‚É£ Gender Distribution**

================================================================================
CELL 11 (CODE)
================================================================================
plt.figure(figsize=(5,4))
sns.countplot(x=df['sex'])
plt.title("Gender Distribution")
plt.show()


--- OUTPUT ---


================================================================================
CELL 12 (MARKDOWN)
================================================================================
**3Ô∏è‚É£ Numerical Feature Summary (Boxplots)**

================================================================================
CELL 13 (CODE)
================================================================================
num_cols = ['albumin','alkaline_phosphatase','alanine_aminotransferase',
            'aspartate_aminotransferase','bilirubin','cholinesterase',
            'cholesterol','creatinina','gamma_glutamyl_transferase','protein']

plt.figure(figsize=(20,20))
df[num_cols].boxplot()
plt.title("Boxplot of Numerical Features")
plt.xticks(rotation=45)
plt.show()


--- OUTPUT ---


================================================================================
CELL 14 (MARKDOWN)
================================================================================
**4Ô∏è‚É£ Correlation Heatmap**

================================================================================
CELL 15 (CODE)
================================================================================
plt.figure(figsize=(10,6))
sns.heatmap(df.select_dtypes(include=['float64','int64']).corr(), annot=False, cmap='coolwarm')
plt.title("Correlation Heatmap (Numeric Features Only)")
plt.show()


--- OUTPUT ---


================================================================================
CELL 16 (MARKDOWN)
================================================================================
**5Ô∏è‚É£ Category vs Key Markers**

================================================================================
CELL 17 (CODE)
================================================================================
important_cols = ['bilirubin','albumin','alanine_aminotransferase','aspartate_aminotransferase','cholesterol']

for col in important_cols:
    plt.figure(figsize=(6,4))
    sns.boxplot(x=df['category'], y=df[col])
    plt.title(f"{col} by Disease Category")
    plt.xticks(rotation=15)
    plt.show()


--- OUTPUT ---


================================================================================
CELL 18 (CODE)
================================================================================
# Recreate X and y after cleaning
X = df.drop(columns=['category'])
y = df['category']

# Split again cleanly
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print("‚úÖ new train/test split done")
print(X_train.shape, X_test.shape)


--- OUTPUT ---
‚úÖ new train/test split done
(492, 12) (123, 12)


================================================================================
CELL 19 (MARKDOWN)
================================================================================
**Model Building**

================================================================================
CELL 20 (MARKDOWN)
================================================================================
**1. Encode Categorical Columns**

================================================================================
CELL 21 (CODE)
================================================================================
from sklearn.preprocessing import LabelEncoder

# Encode categorical columns
le = LabelEncoder()

df['sex'] = le.fit_transform(df['sex'])
df['category'] = le.fit_transform(df['category'])

df.head()

--- OUTPUT ---
   category  age  sex  albumin  alkaline_phosphatase  \
0         3   32    1     38.5                  52.5   
1         3   32    1     38.5                  70.3   
2         3   32    1     46.9                  74.7   
3         3   32    1     43.2                  52.0   
4         3   32    1     39.2                  74.1   

   alanine_aminotransferase  aspartate_aminotransferase  bilirubin  \
0                       7.7                        22.1        7.5   
1                      18.0                        24.7        3.9   
2                      36.2                        52.6        6.1   
3                      30.6                        22.6       18.9   
4                      32.6                        24.8        9.6   

   cholinesterase  cholesterol  creatinina  gamma_glutamyl_transferase  \
0            6.93         3.23       106.0                        12.1   
1           11.17         4.80        74.0                        15.6   
2            8.84         5.20        86.0                        33.2   
3            7.33         4.74        80.0                        33.8   
4            9.15         4.32        76.0                        29.9   

   protein  
0     69.0  
1     76.5  
2     79.3  
3     75.7  
4     68.7  

================================================================================
CELL 22 (MARKDOWN)
================================================================================
**2. Train-Test Split**

================================================================================
CELL 23 (CODE)
================================================================================
from imblearn.over_sampling import SMOTE

sm = SMOTE(random_state=42, k_neighbors=2)
X_train_res, y_train_res = sm.fit_resample(X_train, y_train)

print("Before SMOTE:", y_train.value_counts().to_dict())
print("After SMOTE:", y_train_res.value_counts().to_dict())


--- OUTPUT ---
Before SMOTE: {3: 437, 0: 21, 1: 15, 2: 15, 4: 4}
After SMOTE: {3: 437, 1: 437, 0: 437, 2: 437, 4: 437}


================================================================================
CELL 24 (CODE)
================================================================================
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

print("‚úÖ Scaling successful")


--- OUTPUT ---
‚úÖ Scaling successful


================================================================================
CELL 25 (CODE)
================================================================================
rf_balanced = RandomForestClassifier(
    n_estimators=300,
    random_state=42
)
rf_balanced.fit(X_train_res, y_train_res)
y_pred_balanced = rf_balanced.predict(X_test)

print("Accuracy:", accuracy_score(y_test, y_pred_balanced))
print("\nClassification Report:\n", classification_report(y_test, y_pred_balanced))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred_balanced))


--- OUTPUT ---
‚úÖ Random Forest Model Evaluation

üìå Accuracy: 0.8618

üìä Classification Report:

üßæ Confusion Matrix:


================================================================================
CELL 26 (CODE)
================================================================================
# ========== 1) Imports ==========
import warnings
warnings.filterwarnings("ignore")

import time
import numpy as np
import pandas as pd

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import StratifiedKFold, cross_val_score
from sklearn.metrics import (
    accuracy_score, f1_score, precision_score, recall_score,
    classification_report, confusion_matrix
)
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt

# ========== 2) Define 5 models (with proper scaling where needed) ==========
models = {
    "Logistic Regression": Pipeline([
        ("scaler", StandardScaler()),
        ("clf", LogisticRegression(max_iter=1000, class_weight="balanced", multi_class="multinomial", n_jobs=None))
    ]),
    "KNN (k=5)": Pipeline([
        ("scaler", StandardScaler()),
        ("clf", KNeighborsClassifier(n_neighbors=5))
    ]),
    "SVM (RBF)": Pipeline([
        ("scaler", StandardScaler()),
        ("clf", SVC(kernel="rbf", probability=True, class_weight="balanced", random_state=42))
    ]),
    "Decision Tree": DecisionTreeClassifier(class_weight="balanced", random_state=42),
    "Random Forest": RandomForestClassifier(n_estimators=300, class_weight="balanced_subsample", random_state=42)
}

# ========== 3) Evaluate and collect metrics in a tidy table ==========
rows = []
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

for name, model in models.items():
    t0 = time.time()
    model.fit(X_train, y_train)
    fit_time = time.time() - t0

    t1 = time.time()
    y_pred = model.predict(X_test)
    pred_time = time.time() - t1

    # Holdout metrics (test set)
    acc  = accuracy_score(y_test, y_pred)
    f1m  = f1_score(y_test, y_pred, average="macro", zero_division=0)
    prec = precision_score(y_test, y_pred, average="macro", zero_division=0)
    rec  = recall_score(y_test, y_pred, average="macro", zero_division=0)

    # 5-fold CV on ALL data using macro-F1 (handles imbalance better)
    cv_scores = cross_val_score(model, X_train, y_train, cv=cv, scoring="f1_macro")
    cv_mean, cv_std = cv_scores.mean(), cv_scores.std()

    rows.append({
        "Model": name,
        "Accuracy (test)": round(acc, 4),
        "Macro F1 (test)": round(f1m, 4),
        "Macro Precision (test)": round(prec, 4),
        "Macro Recall (test)": round(rec, 4),
        "CV Macro F1 (mean)": round(cv_mean, 4),
        "CV Macro F1 (std)": round(cv_std, 4),
        "Fit Time (s)": round(fit_time, 3),
        "Predict Time (s)": round(pred_time, 3),
    })

results_df = pd.DataFrame(rows).sort_values(by=["Macro F1 (test)", "Accuracy (test)"], ascending=False).reset_index(drop=True)
results_df


--- OUTPUT ---
                 Model  Accuracy (test)  Macro F1 (test)  \
0  Logistic Regression           0.8374           0.6500   
1        Random Forest           0.8537           0.5555   
2        Decision Tree           0.8293           0.4898   
3            SVM (RBF)           0.8374           0.4394   
4            KNN (k=5)           0.8130           0.3226   

   Macro Precision (test)  Macro Recall (test)  CV Macro F1 (mean)  \
0                  0.6781               0.6701              0.5536   
1                  0.9032               0.4667              0.4687   
2                  0.6874               0.4514              0.4971   
3                  0.4322               0.4472              0.4801   
4                  0.4141               0.3000              0.4491   

   CV Macro F1 (std)  Fit Time (s)  Predict Time (s)  
0             0.1037         0.144             0.002  
1             0.1351         1.603             0.044  
2             0.1207         0.010             0.001  
3             0.0658         0.094             0.006  
4             0.0573         0.005             0.021  

================================================================================
CELL 27 (CODE)
================================================================================
import json
import os

# Read the notebook file
notebook_path = r"c:\Users\sreed\OneDrive\Documents\My Projects\Data Science\Pharma_Classification\pharmaclassfication.ipynb"
output_path = r"c:\Users\sreed\OneDrive\Documents\My Projects\Data Science\Pharma_Classification\pc_text.txt"

with open(notebook_path, 'r', encoding='utf-8') as f:
    notebook = json.load(f)

# Extract and write all cells to text file
with open(output_path, 'w', encoding='utf-8') as f:
    f.write("=" * 80 + "\n")
    f.write("PHARMA CLASSIFICATION NOTEBOOK - FULL EXPORT\n")
    f.write("=" * 80 + "\n\n")
    
    for i, cell in enumerate(notebook['cells'], 1):
        cell_type = cell['cell_type']
        source = ''.join(cell['source']) if isinstance(cell['source'], list) else cell['source']
        
        f.write(f"\n{'='*80}\n")
        f.write(f"CELL {i} ({cell_type.upper()})\n")
        f.write(f"{'='*80}\n")
        f.write(source)
        f.write("\n")
        
        # Add outputs if they exist
        if 'outputs' in cell and cell['outputs']:
            f.write("\n--- OUTPUT ---\n")
            for output in cell['outputs']:
                if output['output_type'] == 'stream':
                    f.write(''.join(output['text']))
                elif output['output_type'] == 'execute_result':
                    f.write(str(output['data']))
                elif output['output_type'] == 'display_data':
                    f.write(str(output['data']))
            f.write("\n")

print(f"‚úÖ Notebook exported to: {output_path}")
print(f"File size: {os.path.getsize(output_path)} bytes")

--- OUTPUT ---
‚úÖ Notebook exported to: c:\Users\sreed\OneDrive\Documents\My Projects\Data Science\Pharma_Classification\pc_text.txt
File size: 482698 bytes

